#+TITLE: Land of Lisp
#+AUTHOR: Vlad Tutunea
#+STARTUP: overview

* Introduction
Lisp is a very /expressive/ language.
Once lisp is learned, one will =dream= in lisp :-)

Simple mafs
#+begin_src lisp
(+ 3 (* 2 4))
#+end_src

One of =Lisp='s core characteristics is that writing a Lisp directly in Lisp is, itself, unbelievably simple. Lisp is both *feature-rich* and *tweakable*
- ANSI Common Lisp
- Scheme

Up and coming Lisps
- Arc
- Clojure

Lisp dialects used for scripting
- Emacs Lisp <3
- Guile Scheme
- Script-Fu

* Chapter 2
** Guess my number
#+begin_src lisp
;; Define global variables
(defparameter *small* 1)
(defparameter *big* 100)

;; Define global functions
(defun guess-my-number ()
  (ash (+ *small* *big*) -1))

(defun smaller ()
  (setf *big* (1- (guess-my-number)))
  (guess-my-number))

(defun bigger ()
  (setf *small* (1+ (guess-my-number)))
  (guess-my-number))

(defun start-over ()
  (defparameter *small* 1)
  (defparameter *big* 100)
  (guess-my-number))

;; (start-over) - use the repl to play
#+end_src

Using =*= is a best practice to mark global variables.

** Defining Local Variables
#+begin_src lisp
(let ((a 5)
	  (b 6))
  (+ a b))
#+end_src

** Defining Local Functions
*** flet
#+begin_src lisp
(flet ((f (n)
		 (+ n 10))
	   (g (n)
		 (- n 3)))
  (g (f 5)))
#+end_src

*** labels - have access to previously defined local functions. Also recursion!!
#+begin_src lisp
(labels ((a (n)
		   (+ n 5))
		 (b (n)
		   (+ (a n) 6)))
  (b 10))
#+end_src

#+begin_src lisp
(defun factorial (N)
  (if (= N 1)
	  1
	  (* N (factorial (- N 1)))))

(factorial 5)
#+end_src

* Chapter 3
Having a simple syntax us a defining feature of the =Lisp= language. All basic Lisp code uses list-like syntax.
** Symbols
=Symbols= are a fundamental type of data in Lisp and are used extensively.
eg: =+ - / * = < > ? ! _=. Other eg: =foo, ice9, my-killer-app27, --<<==>>--=
Symbols are /*case-insensitive*/
#+begin_src lisp
(eq 'fooo 'FoOo)
#+end_src

** Numbers
Lisp supports both floating-point numbers and integers. =1= and =1.0= are two different entities in Common Lisp.
#+begin_src lisp
(expt 53 53)
#+end_src
#+begin_src lisp
(/ 4 6)
#+end_src
This returns a =rational number= rather than a fraction. To get a fraction, we can use floating-point numbers.
#+begin_src lisp
(/ 4.0 6)
#+end_src

** Strings
#+begin_src lisp
(princ "Tutti Frutti")
#+end_src
#+begin_src lisp
(princ "He yelled \"Stop that thief!\" from the busy street.")
#+end_src

** Code mode and Data mode
*** Code Mode
Lisp always defaults to =code mode=. Code should be in a speical type of list: a =form=
=(foo bla bla bla bla)=
foo - command
bla bla bla bla - a form
A form is simply a list with special command at the beginning - typically the name of a function.
Two nested forms
#+begin_src lisp
(expt 2 (+ 3 4))
#+end_src

*** Data Mode
Any stuff written in data mode is treated as data. This means the pc will not try to "execute" it.
#+begin_src lisp
'(expt 2 3)
#+end_src
The single quote tells Lisp to treat the subsequent form as a chunk of data - simply a list of items. By using =quoting=, you can tell Lisp to not execute it.

** Lists in Lisp
Lists are a crucial feature in Lisp.
If you were to build a house in Lisp, your walls would be made out of lists. The bricks would be made out of symbols, numbers, and strings. However, a wall needs mortar to hold it together. In Lisp are held together by structures called =cons cells=.

*** Cons Cells
It's made of two little connected boxes, both of which can point at other things. A cons cell can point to another cons cell or another type of Lisp data. It's possible to link cons cells together into lists. In fact, in Lisp, lists are just an abstract illusion - all of them are actually composed of cons cells. They look like Linked Lists.
=(val, pointer)=

*** List Functions
There are 3 basic functions for manipulating cons cells in Lisp: =cons=, =car=, =cdr=.

**** The =cons= Function
If you want to link any two pieces of data in your Lisp program, the usual way to do that is with cons. When =cons= is called, the Lisp compiler typically allocates a small chunk of memory, the cons cell, that can hold two references to the objects being linked.
#+begin_src lisp
(cons 'chicken 'cat)
#+end_src
#+begin_src lisp
(cons 'chicken 'nil)
#+end_src
=nil= is used to terminate a list. Lisp will always go out of its way to "hide" the cons cells from you. It will show you cons cell *only* if there isn't a way to show your results using lists.

#+begin_src lisp
(cons 'chicken ())
#+end_src
#+begin_src lisp
(cons 'pork '(beef chicken))
#+end_src
#+begin_src lisp
(cons 'beef (cons 'chicken ()))
#+end_src
#+begin_src lisp
(cons 'pork (cons 'beef (cons 'chicken ())))
#+end_src

In Lisp, a chain of cons cells and a list are exactly the same thing.

**** The =car= and =cdr= Functions
Lists are just long chains of two-item cells. The =car= function is used for getting the thing out the /first/ slot of a cell (head).
#+begin_src lisp
(car '(pork beef chicken))
#+end_src

The =cdr= function is used to grab the value out of the /second/ slot, or the remainder of the list (tail).
#+begin_src lisp
(cdr '(pork beef chicken))
#+end_src

=cadr=, =cdar= or =cadadr=
#+begin_src lisp
(cadr '(pork beef chicken))
#+end_src

**** The =list= Function
The /list/ function does the dirty work of creating all the cons cells and builds our list all at once:
#+begin_src lisp
(list 'pork 'beef 'chicken)
#+end_src

#+begin_src lisp
(cons 'pork (cons 'beef (cons 'chicken 'nil)))
#+end_src

**** Nested lists
Lists can contain other lists
#+begin_src lisp
'(cat (duck bat) ant)
#+end_src
#+begin_src lisp
(cdar '((peas carrots tomatoes) (pork beef chicken)))
#+end_src
#+begin_src lisp
(cons (cons 'peas (cons 'carrots (cons 'tomatoes ())))
	  (cons (cons 'pork (cons 'beef (cons 'chicken ()))) ()))
#+end_src

cddr - cdr of the cdr of X.
#+begin_src lisp
(cddr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

caddr - car of the cdr of the cdr of X.
#+begin_src lisp
(caddr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

cddar - cdr of the cdr of the car of X.
#+begin_src lisp
(cddar '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

cadadr - car of the cdr of the car of the cdr of X.
#+begin_src lisp
(cadadr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

* Chapter 4
Lisp commands and data structures are imbued with symmetry in every conceivable way.
Note: In Lisp, an empty list evaluates to false.
#+begin_src lisp
(defun my-length (list)
  (if list
	  (1+ (my-length (cdr list)))
	  0))

(my-length '(list with four symbols))
;; This goes like this:
;; 1 + (with four symbols) -> 1 + (four symbols) -> 1 + (symbols) -> 1 + () -> 0
;; 1 + 1 + 1 + 1 + 0 = 4
#+end_src

** The four disguises of /()/
It is the *only* false value in Common Lisp. /Any value not equivalent to an empty list will be considere a true value/
#+begin_src lisp
(eq '() nil)
(eq '() ())
(eq '() 'nil)
;; These evaluate to true
#+end_src
Funny thing -> =nil= is actually a global constant evaluating to /data-mode/ nil.

** The Conditionals: if and beyond
#+begin_src lisp
(if (oddp 5)
	'odd-number
	'even-number)
#+end_src
Usually, when a function is executed in Lisp, all the expressions after the function name are evaluated, before the function itself is evaluated. However, /if/ does not follow these rules.

Since only one expression inside an /if/ is *ever* evaluated, it's impossible to do two or more separate things inside your branch. =progn= to the rescue...
#+begin_src lisp
(defvar *number-was-odd* nil)

(if (oddp 5)
	(progn (setf *number-was-odd* t)
		   'odd-number)
	'even-number)

,*number-was-odd*

#+end_src

** Beyond /if/
Since it's a pain to use =progn= every time, Lisp has several other commands that include an /implicit/ *progn*
=when= and =unless=
#+begin_src lisp
(defvar *number-is-odd* nil)
(when (oddp 5)
  (setf *number-is-odd* t)
  'odd-number)

,*number-is-odd*

(unless (oddp 4)
  (setf *number-is-odd* nil)
  'even-number)

,*number-is-odd*
#+end_src

The problem with =when= and =unless= is that when the conditions evaluate the opposite way, they just return =nil= and do nothing.
=cond= to the rescue...

** The command that does it all: /cond/
#+begin_src lisp
(defvar *arch-enemy* nil)
(defun pudding-eater (person)
  (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
		 '(curse you lisp alien - you ate my pudding))
		((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
		 '(i hope you choked on my pudding johnny))
		(t '(why you eat my pudding stranger ?))))

(pudding-eater 'johnny)
,*arch-enemy*
#+end_src
use =case=
#+begin_src lisp
(defun pudding-eater-case (person)
  (case person
	((henry) (setf *arch-enemy* 'henry)
	 '(curse you lisp alien))
	((johnny) (setf *arch-enemy* 'johnny)
	 '(i hope you liked the pudding))
	(otherwise '(who ate my pudding ?))))

(pudding-eater-case 'johnny)
#+end_src

** Cool tricks with conditions
Lisp uses shortcut boolean evaluation (similar to javascript).
Some built-in functions returns more than a boolean; eg: =member= returns true if the list contains the search element, but also returns the tail (=cdr=) past searched element.

** Comparing stuff: /eq/, /equal/, and /more/ 
Lisp has a lot of comparing functions to check if two values are "the same".
=equal, eql, eq, =, string-equal, equalp=

Conrad's Rule of Thumb for Comparing Stuff:
1. use =eq= to compare symbols.
2. use =equal= to compare everything else.

#+begin_src lisp
(defparameter *fruit* 'apple)

(cond ((eq *fruit* 'apple) 'its-an-apple)
	  ((eq *fruit* 'orange) 'its-an-orange))

(eql #\a #\a)

#+end_src

* Chapter 5
** Text Adventure Game
#+begin_src lisp
(defparameter *nodes* '((living-room (you are in the living room.
									  a wizard is snoring loudly on the couch.))
						(garden (you are in a beautiful garden.
								 there is a well in front of you.))
						(attic (you are in the attic.
								there is a giant welding torch in the corner.))))

(defparameter *edges* '((living-room (garden west door)
						 (attic upstairs ladder))
						(garden (living-room east door))
						(attic (living-room downstairs ladder))))

(defparameter *objects* '(whiskey bucket frog chain))

(defparameter *object-location* '((whiskey living-room)
								  (bucket living-room)
								  (chain garden)
								  (frog garden)))

(defparameter *location* 'living-room)

(defun describe-location (location nodes)
  (cadr (assoc location nodes)))

(defun describe-path (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))

(defun describe-paths (location edges)
  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))

(defun object-at (location objects object-location)
  (labels ((at-location-p (object)
			 (eq (cadr (assoc object object-location)) location)))
	(remove-if-not #'at-location-p objects)))

(defun describe-objects (location objects object-location)
  (labels ((describe-object (object)
			 `(you see a ,object on the floor.)))
	(apply #'append (mapcar #'describe-object (object-at location objects object-location)))))

(defun look ()
  (append (describe-location *location* *nodes*)
		  (describe-paths *location* *edges*)
		  (describe-objects *location* *objects* *object-location*)))

(defun walk (direction)
  (let ((next (find direction
					(cdr (assoc *location* *edges*))
					:key #'cadr)))
	(if next
		(progn (setf *location* (car next))
			   (look))
		'(you cannot go that way.))))

(defun pickup (object)
  (cond ((member object
				 (object-at *location* *objects* *object-location*))
		 (push (list object 'body) *object-location*)
		 `(you are now carrying the ,object))
		(t '(you cannot get that.))))

(defun drop (object)
  (cond ((member object
				 (object-at 'body *objects* *object-location*))
		 (push (list object *location*) *object-location*)
		 `(you have dropped the ,object at ,*location*))
		 (t `(you are not carrying ,object))))

(defun inventory ()
  (cons 'items- (object-at 'body *objects* *object-location*)))
#+end_src

=quasiquoting= allows us to create chunks of data that have small pieces of Lisp code embedded in them. Looks similar to javascript's template literal.
='= and =`= /flip/ a piece of code in data mode, but only =`= can also be /unquoted/ using the comma character, to flip back into code mode.

The =push/assoc= idiom is a common technique, because =assoc= returns the first found item, "cheating" having the same item twice; it's like the item is being overwritten.

* Chapter 6
=print/read=

#+begin_src lisp
(defun say-hello ()
  (princ "Please type your name:")
  (let ((name (read-line)))
	(princ "Hello, ")
	(princ name)))
#+end_src
A programming language that uses the same data structures to store and and program code is called =homoiconic=.
Lisp has the infamous =eval= function... Javascript feelings...

#+begin_src lisp
(defparameter *allowed-commands* '(look walk pickup drop inventory))

(defun game-read ()
  (let ((cmd (read-from-string
			  (concatenate 'string "(" (read-line) ")"))))
	(flet ((quote-it (x)
			 (list 'quote x)))
	  (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))

(defun game-eval (sexp)
  (if (member (car sexp) *allowed-commands*)
	  (eval sexp)
	  '(command unknown - try again with "look" "walk" "pickup" "drop" "inventory")))

(defun tweak-text (lst caps lit)
  (when lst
	(let ((item (car lst))
		  (rest (cdr lst)))
	  (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
			((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
			((eq item #\") (tweak-text rest caps (not lit)))
			((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
			(t (cons (char-downcase item) (tweak-text rest nil nil)))))))

(defun game-print (lst)
  (princ (coerce (tweak-text (coerce (string-trim "() "
												  (prin1-to-string lst))
									 'list)
							 t
							 nil)
				 'string))
  (fresh-line))

(defun game-repl ()
  (let ((cmd (game-read)))
	(unless (eq (car cmd) 'quit)
	  (game-print (game-eval cmd))
	  (game-repl))))
#+end_src

* Chapter 6.5
=lambda= - anonymous function.
#+begin_src lisp
(mapcar (lambda (n) (/ n 2)) '(2 4 6))
#+end_src
because not all parameters of the =lambda= command are evaluated, =lambda= itself is not actually a true function, but rahter something called =macro=.
=higher-order functional programming=

* Chapter 7
#+begin_src lisp
(cons 1 (cons 2 3))
#+end_src
To indicate that the final item in the list wasn't found in the proper location for a =nil-terminated= list, Lisp places a /dot/ in front of this final item.
A list in Lisp that ends in something other than =nil= is referred to as a =dotted list=.
One common and practical use for dotted lists in Lisp programs is to elegantly represent pairs.
#+begin_src lisp
(cons 2 3)
#+end_src

** Circular Lists
#+begin_src lisp
(setf *print-circle* t)
(defparameter foo '(1 2 3))
(setf (cdddr foo) foo)
#+end_src

** Association lists - alist
alist - key/value pairs stored in a list.
#+begin_src lisp
(defparameter *drink-order* '((bill . double-expresso)
							  (lisa . small-drip-coffee)
							  (john . medium-latte)))
(cdr (assoc 'lisa *drink-order*))
#+end_src

** Complicated Data
*** Tree-like Data
#+begin_src lisp
(defparameter *house* '((walls (mortar (cement)
								(water)
								(sand))
						 (bricks))
						(windows (glass)
						 (frame)
						 (curtains))
						(roof (shingles)
						 (chimney))))
#+end_src

#+begin_src lisp
(defparameter *wizard-nodes* '((living-room (you are in the living-room.
											 a wizard is snoring loudly on the couch.))
							   (garden (you are in a beautiful garden.
										there is a well in front of you.))
							   (attic (you are in the attic. there
									   is a giant welding torch in the corner.))))
(defparameter *wizard-edges* '((living-room (garden west door)
								(attic upstairs ladder))
							   (garden (living-room east door))
							   (attic (living-room downstairs ladder))))
#+end_src

*** Converting Node Identifiers
#+begin_src lisp
(defun dot-name (exp)
  (substitute-if #\_ (complement #'alphanumericp) (prin1-to-string exp)))
#+end_src

#+begin_src lisp
(defparameter *max-label-length* 30)

(defun dot-label (exp)
  (if exp
	  (let ((s (write-to-string exp :pretty nil)))
		(if (> (length s) *max-label-length*)
			(concatenate 'string (subseq s 0 (- *max-label-length* 3)) "...")
			s))
	  ""))
#+end_src

#+begin_src lisp
(defun nodes->dot (nodes)
  (mapc (lambda (node)
		  (fresh-line)
		  (princ (dot-name (car node)))
		  (princ "[label=\"")
		  (princ (dot-label node))
		  (princ "\"];"))
		nodes))
#+end_src

#+begin_src lisp
(defun edges->dot (edges)
  (mapc (lambda (node)
		  (mapc (lambda (edge)
				  (fresh-line)
				  (princ (dot-name (car node)))
				  (princ "->")
				  (princ (dot-name (car edge)))
				  (princ "[label=\"")
				  (princ (dot-label (cdr edge)))
				  (princ "\"];"))
				(cdr node)))
		edges))
#+end_src

#+begin_src lisp
(defun graph->dot (nodes edges)
  (princ "digraph{")
  (nodes->dot nodes)
  (edges->dot edges)
  (princ "}"))
#+end_src

#+begin_src lisp
(defun dot->png (fname thunk)
  (with-open-file (*standard-output*
				   fname
				   :direction :output
				   :if-exists :supersede)
	(funcall thunk))
  (ext:shell (concatenate 'string "dot -Tpng -O " fname)))
#+end_src

#+begin_src lisp
(defun graph->png (fname nodes edges)
  (dot->png fname
			(lambda ()
			  (graph->dot nodes edges))))
#+end_src

#+begin_src lisp
(defun uedges->dot (edges)
  (maplist (lambda (lst)
			 (mapc (lambda (edge)
					 (unless (assoc (car edge) (cdr lst))
					   (fresh-line)
					   (princ (dot-name (caar lst)))
					   (princ "--")
					   (princ (dot-name (car edge)))
					   (princ "[label=\"")
					   (princ (dot-label (cdr edge)))
					   (princ "\"];")))
				   (cdar lst)))
		   edges))

(defun ugraph->dot (nodes edges)
  (princ "graph{")
  (nodes->dot nodes)
  (uedges->dot edges)
  (princ "}"))

(defun ugraph->png (fname nodes edges)
  (dot->png fname
			(lambda ()
			  (ugraph->dot nodes edges))))
#+end_src

* Chapter 8

#+begin_src lisp
(load "graph-util")

(defparameter *congestion-city-nodes* nil)
(defparameter *congestion-city-edges* nil)
(defparameter *visited-nodes* nil)
(defparameter *node-num* 30)
(defparameter *edge-num* 45)
(defparameter *worm-num* 3)
(defparameter *cop-odds* 15)

(defun random-node ()
  (1+ (random *node-num*)))

(defun edge-pair (a b)
  (unless (eql a b)
	(list (cons a b) (cons b a))))

(defun make-edge-list ()
  (apply #'append (loop repeat *edge-num*
						collect (edge-pair (random-node) (random-node)))))
#+end_src

#+RESULTS:
: MAKE-EDGE-LIST

Examples of the =loop= command
#+begin_src lisp
(loop repeat 10
	  collect 1)

(loop for n from 1 to 10
	  collect n)

(loop for n from 1 to 10
	  collect (+ 100 n))
#+end_src

#+begin_src lisp
(defun direct-edges (node edge-list)
  (remove-if-not (lambda (x)
				   (eql (car x) node))
				 edge-list))

(defun get-connected (node edge-list)
  (let ((visited nil))
	(labels ((traverse (node)
			   (unless (member node visited)
				 (push node visited)
				 (mapc (lambda (edge)
						 (traverse (cdr edge)))
					   (direct-edges node edge-list)))))
	  (traverse node))
	visited))

(defun find-islands (nodes edge-list)
  (let ((islands nil))
	(labels ((find-island (nodes)
			   (let* ((connected (get-connected (car nodes) edge-list))
					  (unconnected (set-difference nodes connected)))
				 (push connected islands)
				 (when unconnected
				   (find-island unconnected)))))
	  (find-island nodes))
	islands))

(defun connect-with-bridges (islands)
  (when (cdr islands)
	(append (edge-pair (caar islands) (caadr islands))
			(connect-with-bridges (cdr islands)))))

(defun connect-all-islands (nodes edge-list)
  (append (connect-with-bridges (find-islands nodes edge-list)) edge-list))
#+end_src

#+begin_src lisp
(defun make-city-edges ()
  (let* ((nodes (loop for i from 1 to *node-num*
					  collect i))
		 (edge-list (connect-all-islands nodes (make-edge-list)))
		 (cops (remove-if-not (lambda (x)
								(zerop (random *cop-odds*)))
							  edge-list)))
	(add-cops (edges-to-alist edge-list) cops)))

(defun edges-to-alist (edge-list)
  (mapcar (lambda (node1)
			(cons node1
				  (mapcar (lambda (edge)
							(list (cdr edge)))
						  (remove-duplicates (direct-edges node1 edge-list)
											 :test #'equal))))
		  (remove-duplicates (mapcar #'car edge-list))))

(defun add-cops (edge-alist edges-with-cops)
  (mapcar (lambda (x)
			(let ((node1 (car x))
				  (node1-edges (cdr x)))
			  (cons node1
					(mapcar (lambda (edge)
							  (let ((node2 (car edge)))
								(if (intersection (edge-pair node1 node2)
												  edges-with-cops
												  :test #'equal)
									(list node2 'cops)
									edge)))
							node1-edges))))
		  edge-alist))
#+end_src

#+begin_src lisp
(defun neighbors (node edge-alist)
  (mapcar #'car (cdr (assoc node edge-alist))))

(defun within-one (a b edge-alist)
  (member b (neighbors a edge-alist)))

(defun within-two (a b edge-alist)
  (or (within-one a b edge-alist)
	  (some (lambda (x)
			  (within-one x b edge-alist))
			(neighbors a edge-alist))))

(defun make-city-nodes (edge-alist)
  (let ((wumpus (random-node))
		(glow-worms (loop for i below *worm-num*
						  collect (random-node))))
	(loop for n from 1 to *node-num*
		  collect (append (list n)
						  (cond ((eql n wumpus) '(wumpus))
								((within-two n wumpus edge-alist) '(blood!)))
						  (cond ((member n glow-worms)
								 '(glow-worm))
								((some (lambda (worm)
										 (within-one n worm edge-alist))
									   glow-worms)
								 '(lights!)))
						  (when (some #'cdr (cdr (assoc n edge-alist)))
							'(sirens!))))))
#+end_src

#+begin_src lisp
(defun new-game ()
  (setf *congestion-city-edges* (make-city-edges))
  (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
  (setf *player-pos* (find-empty-node))
  (setf *visited-nodes* (list *player-pos*))
  (draw-city))

(defun find-empty-node ()
  (let ((x (random-node)))
	(if (cdr (assoc x *congestion-city-nodes*))
		(find-empty-node)
		x)))

(defun draw-city ()
  (ugraph->png "city" *congestion-city-nodes* *congestion-city-edges*))
#+end_src

#+begin_src lisp
(defun known-city-nodes ()
  (mapcar (lambda (node)
			(if (member node *visited-nodes*)
				(let ((n (assoc node *congestion-city-nodes*)))
				  (if (eql node *player-pos*)
					  (append n '(*))
					  n))
				(list node '?)))
		  (remove-duplicates
		   (append *visited-nodes*
				   (mapcan (lambda (node)
							 (mapcar #'car
									 (cdr (assoc node
												 ,*congestion-city-edges*))))
						   ,*visited-nodes*)))))

(defun known-city-edges ()
  (mapcar (lambda (node)
			(cons node (mapcar (lambda (x)
								 (if (member (car x) *visited-nodes*)
									 x
									 (list (car x))))
							   (cdr (assoc node *congestion-city-edges*)))))
		  ,*visited-nodes*))

(defun draw-known-city ()
  (ugraph->png "known-city" (known-city-nodes) (known-city-edges)))

(defun new-game ()
  (setf *congestion-city-edges* (make-city-edges))
  (setf *congestion-city-nodes* (make-city-nodes *congestion-city-edges*))
  (setf *player-pos* (find-empty-node))
  (setf *visited-nodes* (list *player-pos*))
  (draw-city)
  (draw-known-city))
#+end_src

#+begin_src lisp
(defun walk (pos)
  (handle-direction pos nil))

(defun charge (pos)
  (handle-direction pos t))

(defun handle-direction (pos charging)
  (let ((edge (assoc pos
					 (cdr (assoc *player-pos* *congestion-city-edges*)))))
	(if edge
		(handle-new-place edge pos charging)
		(princ "That location does not exist!"))))

(defun handle-new-place (edge pos charging)
  (let* ((node (assoc pos *congestion-city-nodes*))
		 (has-worm (and (member 'glow-worm node)
						(not (member pos *visited-nodes*)))))
	(pushnew pos *visited-nodes*)
	(setf *player-pos* pos)
	(draw-known-city)
	(cond ((member 'cops edge) (princ "You ran into the cops. Game Over."))
		  ((member 'wumpus node) (if charging
									 (princ "You found the Wumpus!")
									 (princ "You ran into the Wumpus")))
		  (charging (princ "You wasted your last bullet. Game Over."))
		  (has-worm (let ((new-pos (random-node)))
					  (princ "You ran into a Glow Worm Gang! You're now at ")
					  (princ new-pos)
					  (handle-new-place nil new-pos nil))))))
#+end_src

* Chapter 9
#+begin_src lisp
(make-array 3)
#+end_src
The Common Lisp language is said to support =generic setter=. This means that in most cases, the code for =pulling a value out of= a data structure is identical to the code for =putting data into= that same data structure.

#+begin_src lisp
(setf foo (make-array 4))
(setf (aref foo 2) '(x y z))
(setf (car (aref foo 2)) (make-hash-table))
(setf (gethash 'zoink (car (aref foo 2))) 5)
foo
#+end_src

#+begin_src lisp
(nth 0 '(foo bar baz))
#+end_src

** Hash Tables
Sort of like =alists=, except that they also allow you to access arbitrary elements more quickly.
#+begin_src lisp
(defparameter x (make-hash-table))
(setf (gethash 'yup x) '25)
(gethash 'yup x)
#+end_src

*** Returning Multiple Values
Common Lisp allows you to return more than one value as a result.
#+begin_src lisp
(round 2.4)
#+end_src
Lisp considers the first value to be more important, and it will always be used by default during follow-up calculations.

*** Performance
As with arrays, accessing and modifying a value inside a hash table requires only a constant amount of time, no matter how many items your hash table contains.
A good rule of thumb is to stay away from arrays and hash tables as you conceive a new piece of code. Then, if performance ends up becoming an issue, and only then, judiciously modify the critical sections of your code to take advantage of arrays and hash tables to resolve any performance problems.

*** Fixing the Wumpus (Chapter 8) code
#+begin_src lisp
(defun hash-edges (edge-list)
  (let ((tab (make-hash-table)))
	(mapc (lambda (x)
			(let ((node (x)))
			  (push (cdr x) (gethash node tab))))
		  edge-list)
	tab))

(defun get-connected-hash (node edge-tab)
  (let ((visited (make-hash-table)))
	(labels ((traverse (node)
			   (unless (gethash node visited)
				 (setf (gethash node visited) t)
				 (mapc (lambda (edge)
						 (traverse edge))
					   (gethash node edge-tab)))))
	  (traverse node))
	visited))
#+end_src

** Common Lisp Structures
A =structure= is an advanced datatype available in Common Lisp.
#+begin_src lisp
(defstruct person
  name
  age
  waist-size
  favorite-color)

(defparameter *bob* (make-person :name "Bob"
								 :age 35
								 :waist-size 32
								 :favorite-color "blue"))

,*bob*
#+end_src

*** When to Use Structure
Lisp can do OOP.
#+begin_src lisp
(defun make-person (name age waist-size favorite-color)
  (list name age waist-size favorite-color))

(defun person-age (person)
  (cadr person))

(defparameter *bob* (make-person "bob" 35 32 "blue"))

(person-age *bob*)
#+end_src

** Handling Data in a Generic Way
=sequence functions= work generally across the three main ways of sequencing objects in Lisp: lists, arrays and string.
=length=
search sequences: =find-if=, =count=, =position=, =some= and =every=
sequence function for iterating across a sequence: =reduce=
#+begin_src lisp
(reduce #'+ '(3 4 6 5 2) :initial-value 10 :start 3)
#+end_src

Exercise: find the largest even number in the list: =(7 4 6 5 2)= -> =6=
#+begin_src lisp
(reduce (lambda (best item)
		  (if (and (evenp item) (> item best))
			  item
			  best))
		'(7 4 6 5 2)
		:initial-value 0)
#+end_src

The =map= function works on all sequence types, not just lists.
#+begin_src lisp
(map 'string
	 (lambda (x)
	   (if (eq x #\s)
		   #\S
		   x))
	 "this is a string")
#+end_src

#+RESULTS:
: thiS iS a String

=subseq=
#+begin_src lisp
(subseq "america" 2 6)
#+end_src
=sort=
#+begin_src lisp
(defparameter *my-list* '(8 2 3 7 2 1))
(sort *my-list* #'<)
*my-list*
#+end_src

*** Creating Generic Functions with Type Predicates
Dynamically typed language !!
#+begin_src lisp
(symbolp 6)
#+end_src

#+begin_src lisp
(defun add (a b)
  (cond ((and (numberp a) (numberp b)) (+ a b))
		((and (listp a) (listp b)) (append a b))))

(add 3 4)
(add '(a b) '(c d))
#+end_src

=defmethod= let us define multiple versions of a function that each supports different types.
#+begin_src lisp
(defmethod add2 ((a number) (b number))
  (+ a b))

(defmethod add2 ((a list) (b list))
  (append a b))

(add 3 8)
(add '(a b) '(c d))
#+end_src

#+RESULTS:
| A | B | C | D |

** The Orc Battle Game
*** Code
#+begin_src lisp
(defparameter *player-health* nil)
(defparameter *player-agility* nil)
(defparameter *player-strength* nil)

(defparameter *monsters* nil)
(defparameter *monster-builders* nil)
(defparameter *monster-num* 12)

(defun randval (n)
  "Functions returns 1 to n."
  (1+ (random (max 1 n))))

(defun orc-battle ()
  "This function will initialize the monsters and start the game loop."
  (init-monsters)
  (init-player)
  (game-loop)
  (when (player-dead)
	(princ "You have been killed. Game Over."))
  (when (monsters-dead)
	(princ "Congratulations! You have vanquished all of your foes.")))

(defun game-loop ()
  (unless (or (player-dead) (monsters-dead))
	(show-player)
	(dotimes (k (1+ (truncate (/ (max 0 *player-agility*) 15))))
	  (unless (monsters-dead)
		(show-monsters)
		(player-attack)))
	(fresh-line)
	(map 'list
		 (lambda (m)
		   (or (monster-dead m) (monster-attack m)))
		 ,*monsters*)
	(game-loop)))

(defun init-player ()
  "Setting the inital player stats."
  (setf *player-health* 30)
  (setf *player-agility* 30)
  (setf *player-strength* 30))

(defun player-dead ()
  (<= *player-health* 0))

(defun show-player ()
  (fresh-line)
  (princ "You are a valiant knight with a health of ")
  (princ *player-health*)
  (princ ", an agility of ")
  (princ *player-agility*)
  (princ ", and a strength of ")
  (princ *player-strength*))

(defun player-attack ()
  (fresh-line)
  (princ "Attack style: [s]tab [d]ouble swing [r]oundhouse:")
  (case (read)
	(s (monster-hit (pick-monster)
					(+ 2 (randval (ash *player-strength* -1)))))
	(d (let ((x (randval (truncate (/ *player-strength* 6)))))
		 (princ "Your double swing has a strength of ")
		 (princ x)
		 (fresh-line)
		 (monster-hit (pick-monster) x)
		 (unless (monsters-dead)
		   (monster-hit (pick-monster) x))))
	(otherwise (dotimes (x (1+ (randval (truncate (/ *player-strength* 3)))))
				 (unless (monsters-dead)
				   (monster-hit (random-monster) 1))))))

(defun random-monster ()
  (let ((m (aref *monsters* (random (length *monsters*)))))
	(if (monster-dead m)
		(random-monster)
		m)))

(defun pick-monster ()
  (fresh-line)
  (princ "monster #: ")
  (let ((x (read)))
	(if (not (and (integerp x) (>= x 1) (<= x *monster-num*)))
		(progn (princ "That is not a valid monster number.")
			   (pick-monster))
		(let ((m (aref *monsters* (1- x))))
		  (if (monster-dead m)
			  (progn (princ "That monster is already dead.")
					 (pick-monster))
			  m)))))

(defun init-monsters ()
  (setf *monsters*
		(map 'vector
			 (lambda (x)
			   (funcall (nth (random (length *monster-builders*))
							 ,*monster-builders*)))
			 (make-array *monster-num*))))

(defun monster-dead (m)
  (<= (monster-health m) 0))

(defun monsters-dead ()
  (every #'monster-dead *monsters*))

(defun show-monsters ()
  (fresh-line)
  (princ "Your foes: ")
  (let ((x 0))
	(map 'list
		 (lambda (m)
		   (fresh-line)
		   (princ "   ")
		   (princ (incf x))
		   (princ ". ")
		   (if (monster-dead m)
			   (princ "**dead**")
			   (progn (princ "(Health=")
					  (princ (monster-health m))
					  (princ ") ")
					  (monster-show m))))
		 ,*monsters*)))

(defstruct monster (health (randval 10)))

(defmethod monster-hit (m x)
  (decf (monster-health m) x)
  (if (monster-dead m)
	  (progn (princ "You killed the ")
			 (princ (type-of m))
			 (princ "! "))
	  (progn (princ "You hit the ")
			 (princ (type-of m))
			 (princ ", knocking off ")
			 (princ x)
			 (princ " health points"))))

(defmethod monster-show (m)
  (princ "A fierce ")
  (princ (type-of m)))

(defmethod monster-attack (m))

(defstruct (orc (:include monster)) (club-level (randval 8)))
(push #'make-orc *monster-builders*)

(defmethod monster-show ((m orc))
  (princ "A wicked orc with a level ")
  (princ (orc-club-level m))
  (princ " club"))

(defmethod monster-attack ((m orc))
  (let ((x (randval (orc-club-level m))))
	(princ "An orc swings his club at you and knocks off ")
	(princ x)
	(princ " of your health points. ")
	(decf *player-health* x)))

(defstruct (hydra (:include monster)))
(push #'make-hydra *monster-builders*)

(defmethod monster-show ((m hydra))
  (princ "A malicious hydra with ")
  (princ (monster-health m))
  (princ " heads."))

(defmethod monster-hit ((m hydra) x)
  (decf (monster-health m) x)
  (if (monster-dead m)
	  (princ "The corpse of the fully decapitated and decapacitated hydra falls to the floow!")
	  (progn (princ "You lop off ")
			 (princ x)
			 (princ " of the hydra's heads!"))))

(defmethod monster-attack ((m hydra))
  (let ((x (randval (ash (monster-health m) -1))))
	(princ "A hydra attack you with ")
	(princ x)
	(princ " of its heads! It also grows back on more head.")
	(incf (monster-health m))
	(decf *player-health* x)))

(defstruct (slime-mold (:include monster)) (sliminess (randval 5)))
(push #'make-slime-mold *monster-builders*)

(defmethod monster-show ((m slime-mold))
  (princ "A slime mold with a sliminess of ")
  (princ (slime-mold-sliminess m)))

(defmethod monster-attack ((m slime-mold))
  (let ((x (randval (slime-mold-sliminess m))))
	(princ "A slime mold wraps around your legs and decreases your agility by ")
	(princ x)
	(princ "! ")
	(decf *player-agility* x)
	(when (zerop (random 2))
	  (princ "It also squirts in your face, taking away a health point! ")
	  (decf *player-health*))))

(defstruct (brigand (:include monster)))
(push #'make-brigand *monster-builders*)

(defmethod monster-show ((m brigand))
  (princ "A fierce brigand with ")
  (princ (monster-health m))
  (princ " health points."))

(defmethod monster-attack ((m brigand))
  (let ((x (max *player-health* *player-agility* *player-strength*)))
	(cond ((= x *player-health*)
		   (princ "A brigand hits you with his slingshot, taking off 2 health points! ")
		   (decf *player-health* 2))
		  ((= x *player-agility*)
		   (princ "A brigand catches your leg with his whip, taking off 2 agility points! ")
		   (decf *player-agility* 2))
		  ((= x *player-strength*)
		   (princ "A brigand cuts your arm with his whip, taking off 2 strength points! ")
		   (decf *player-strength* 2)))))
#+end_src

* Chapter 10
=loop= and =format= commands are very powerful and hacker-friendly.
#+begin_src lisp
(loop for i below 5 sum i)
#+end_src

#+begin_src lisp
(loop for i in '(100 20 3)
	  sum i)
#+end_src

#+begin_src lisp
(loop for i below 10
	  when (oddp i)
		sum i)
#+end_src

** Collecting a List of Values
#+begin_src lisp
(loop for i in '(2 3 4 5 6)
	  collect (* i i))
#+end_src

** Evolution Game
#+begin_src lisp
(defparameter *width* 100)
(defparameter *height* 30)
(defparameter *jungle* '(45 10 10 10))
(defparameter *plant-energy* 80)

(defparameter *plants* (make-hash-table :test #'equal))

(defun random-plant (left top width height)
  (let ((pos (cons (+ left (random width)) (+ top (random height)))))
	(setf (gethash pos *plants*) t)))

(defun add-plants ()
  (apply #'random-plant *jungle*)
  (random-plant 0 0 *width* *height*))

(defstruct animal x y energy dir genes)

(defparameter *animals*
  (list (make-animal :x (ash *width* -1)
					 :y (ash *height* -1)
					 :energy 1000
					 :dir 0
					 :genes (loop repeat 8
								  collecting (1+ (random 10))))))

(defun move (animal)
  (let ((dir (animal-dir animal))
		(x (animal-x animal))
		(y (animal-y animal)))
	(setf (animal-x animal) (mod (+ x
									(cond ((and (>= dir 2) (< dir 5)) 1)
										  ((or (= dir 1) (= dir 5)) 0)
										  (t -1))
									,*width*)
								 ,*width*))
	(setf (animal-y animal) (mod (+ y
									(cond ((and (>= dir 0) (< dir 3)) -1)
										   ((and (>= dir 4) (< dir 7)) 1)
										   (t 0))
										  ,*height*)
									,*height*))
		  (decf (animal-energy animal))))

(defun turn (animal)
  (let ((x (random (apply #'+ (animal-genes animal)))))
	(labels ((angle (genes x)
			   (let ((xnu (- x (car genes))))
				 (if (< xnu 0)
					 0
					 (1+ (angle (cdr genes) xnu))))))
	  (setf (animal-dir animal)
			(mod (+ (animal-dir animal) (angle (animal-genes animal) x))
				 8)))))

(defun eat (animal)
  (let ((pos (cons (animal-x animal) (animal-y animal))))
	(when (gethash pos *plants*)
	  (incf (animal-energy animal) *plant-energy*)
	  (remhash pos *plants*))))

(defparameter *reproduction-energy* 200)

(defun reproduce (animal)
  (let ((e (animal-energy animal)))
	(when (>= e *reproduction-energy*)
	  (setf (animal-energy animal) (ash e -1))
	  (let ((animal-nu (copy-structure animal))
			(genes (copy-list (animal-genes animal)))
			(mutation (random 8)))
		(setf (nth mutation genes) (max 1 (+ (nth mutation genes) (random 3) -1)))
		(setf (animal-genes animal-nu) genes)
		(push animal-nu *animals*)))))


(defun update-world ()
  (setf *animals* (remove-if (lambda (animal)
							   (<= (animal-energy animal) 0))
							 ,*animals*))
  (mapc (lambda (animal)
		  (turn animal)
		  (move animal)
		  (eat animal)
		  (reproduce animal))
		,*animals*)
  (add-plants))

(defun draw-world ()
  (loop for y
		  below *height*
		do (progn (fresh-line)
				  (princ "|")
				  (loop for x
						  below *width*
						do (princ (cond ((some (lambda (animal)
												 (and (= (animal-x animal) x)
													  (= (animal-y animal) y)))
											   ,*animals*)
										 #\M)
										((gethash (cons x y) *plants*) #\*)
										(t #\space))))
				  (princ "|"))))

(defun evolution ()
  (draw-world)
  (fresh-line)
  (let ((str (read-line)))
	(cond ((equal str "quit") ())
		  (t (let ((x (parse-integer str :junk-allowed t)))
			   (if x
				   (loop for i
						   below x
						 do (update-world)
						 if (zerop (mod i 1000))
						   do (princ #\.))
				   (update-world))
			   (evolution))))))
#+end_src

* Chapter 11
#+begin_src lisp
(format t "Add onion rings for only ~$ dollars more!" 1.5)
#+end_src

t - destination parameter: =nil=, =t=, =stream=
= nil    -> no printing; returns the value as a string.
= t      -> prints to console, and returns =nil=.
= strea -> writes data to an output stream.

= ~$ -> monetary floating-point.
= ~s -> shows value with delimiters.
= ~a -> shows value human readable.
= ~Xa -> X - padding with blank space to the right of val.
= ~X@a -> X@ - padding with blank spaces to the left of val.
= ~x -> hexadecimal number.
= ~b -> binary number.
= ~d -> decimal number.
= ~4f -> 4 characters floating number.
= ~% -> new line in all cases.
= ~& -> new line only if needed.

* Chapter 12
When we communicate with an external resource from CLisp program, we do so by using a stream.
Stream types:
- Console streams - REPL
- File streams - read/write files on our hard drive
- Socket streams - communicate with other computers on a network
- String streams - send/receive text from a Lisp string

#+begin_src lisp
(output-stream-p *standard-output*)
#+end_src

#+begin_src lisp
(with-open-file (my-stream "data.txt" :direction :output)
  (print "my data still" my-stream))
#+end_src

#+begin_src lisp
(with-open-file (my-stream "data.txt" :direction :input)
  (read my-stream))
#+end_src

#+begin_src lisp
(let ((animal-noises '((dog . woof)
					   (cat . meow))))
  (with-open-file (my-stream "animal-noises.txt" :direction :output)
	(print animal-noises my-stream)))

(with-open-file (my-stream "animal-noises.txt" :direction :input)
  (read my-stream))
#+end_src

** Sockets
A =socket= is a mechanism for routing data over a computer network between programs running on different computers on that network.
- IP address
- Port number
Any messages running over the network  (through chunks of data called /TCP/ =packets=) will be labeled with a socket address to indicate their destination.
First step is to have one of the programs create a socket that starts in a listening state, waiting to see if other programs on the network want to start a communication.
Computer with socket in a listening state - =server=
Program, called =client= creates a socket on its end and uses it to establish a connection with the server.

** String Streams
Makes a string look like a stream.
It can help with performance. Instead of concat two large strings (as the compiler needs to create a new/big block of memory if using the concat).

* Chapter 13
WEB SERVER - =web-server.lisp=

#+begin_src lisp
(error "foo")
#+end_src

Custom error func
#+begin_src lisp
(define-condition foo () ()
  (:report (lambda (condition stream)
			 (princ "Stopp FOOing around, numbskull" stream))))
#+end_src

* Chapter 14
#+begin_src lisp
;; the clean, functional part
(defun add-widget (database widget)
  (cons widget database))

;;  the dirty, nonfunctional part
(defparameter *database* nil)

(defun main-loop ()
  (loop (princ "Please enter the name of a new widget: ")
		(setf *database* (add-widget *database* (read)))
		(format t "The database contains the following: ~a~%" *database*)))
#+end_src

** Higher-Order Programming
Combining different chunks of code to perform a single action - =code composition=.
The most powerful tool - =higher-order programming=.

#+begin_src lisp
(defparameter *my-list* '(4 7 2 3))

;; Imperative
;; (loop for n below (length *my-list*)
;; 	  do (setf (nth n *my-list*) (+ (nth n *my-list*) 2)))

(defun add-two (list)
  (when list
	(cons (+ 2 (car list))
		  (add-two (cdr list)))))

(defun add-two-to-number (n)
  (+ 2 n))

,*my-list*

(add-two *my-list*)

(add-two-to-number '9)

(mapcar #'add-two-to-number *my-list*)
#+end_src

* Chapter 15
=closures= - extra bits of data from the outside world that are captured whenever a lambda function is crated.
#+begin_src lisp
(defparameter *foo* (let ((x 5))
					  (lambda ()
						x)))

(funcall *foo*)
#+end_src

=memoization= uses closures.
=tail call optimization= 

* Chapter 16
=Macros=
#+begin_src lisp
(defmacro let1 (var val &body body)
  `(let ((,var ,val))
	 ,@body))

(let1 foo (+ 2 3)
	  (* foo foo))
#+end_src

You can expose variables from the macro. Macros that automatically generate variables are called =anaphoric macros=.
Macros can contain other macros.
To avoid var name collision, clisp provides a function, =gensym= to generate random, weird string names for the closure variables.
Macros allow us to write code that generates other code.

* Chapter 17
=DSL=

#+begin_src lisp
(defmacro split (val yes no)
  (let1 g (gensym)
	`(let1 ,g ,val
	   (if ,g
		   (let ((head (car ,g))
				 (tail (cdr ,g)))
			 ,yes)
		   ,no))))

(defun pairs (lst)
  (labels ((f (lst acc)
			 (split lst
					(if tail
						(f (cdr tail) (cons (cons head (car tail)) acc))

						(reverse acc))
					(reverse acc))))
	(f lst nil)))

(defun print-tag (name alst closingp)
  (princ #\<)
  (when closingp
	(princ #\/))
  (princ (string-downcase name))
  (mapc (lambda (attr)
		  (format t " ~a=\"~a\"" (string-downcase (car attr)) (cdr attr)))
		alst)
  (princ #\>))

(defmacro tag (name attrs &body body)
  `(progn (print-tag ',name
					 (list ,@(mapcar (lambda (x)
									   `(cons ',(car x) ,(cdr x)))
									 (pairs attrs)))
					 nil)
		  ,@body
		  (print-tag ',name nil t)))

(defmacro html (&body body)
  `(tag html ()
	 ,@body))

(defmacro body (&body body)
  `(tag body ()
	 ,@body))

(defmacro svg (&body body)
  `(tag svg (xmlns "http://www.w3.org/2000/svg"
				   "xmlns:xlink" "http://www.w3.org/1999/xlink")
	 ,@body))

(defun brightness (col amt)
  (mapcar (lambda (x)
			(min 255 (max 0 (+ x amt))))
		  col))

(defun svg-style (color)
  (format nil "~{fill:rgb(~a,~a,~a);stroke:rgb(~a,~a,~a)~}"
		  (append color (brightness color -100))))

(defun circle (center radius color)
  (tag circle (cx (car center)
				  cy (cdr center)
				  r radius
				  style (svg-style color))))

(defun polygon (points color)
  (tag polygon (points (format nil "~{~a,~a ~}"
							   (mapcan (lambda (tp)
										 (list (car tp) (cdr tp)))
									   points))
					   style (svg-style color))))

(defun random-walk (value length)
  (unless (zerop length)
	(cons value
		  (random-walk (if (zerop (random 2))
						   (1- value)
						   (1+ value))
					   (1- length)))))

(with-open-file (*standard-output* "random_walk.svg"
								   :direction :output
								   :if-exists :supersede)
  (svg (loop repeat 10
			 do (polygon (append  '((0 . 200))
								  (loop for x from 0
										for y in (random-walk 100 400)
										collect (cons x y))
								  '((400 . 200)))
						 (loop repeat 3
							   collect (random 256))))))
#+end_src

* Chapter 18
#+begin_src lisp
(defmacro lazy (&body body)
  (let ((forced (gensym))
		(value (gensym)))
	`(let ((,forced nil)
		   (,value nil))
	   (lambda ()
		 (unless ,forced
		   (setf ,value (progn ,@body))
		   (setf ,forced t))
		 ,value))))

(defun force (lazy-value)
  (funcall lazy-value))

(lazy (+ 1 2))
(force (lazy (+ 1 2)))
#+end_src

** Lazy Lists Library
#+begin_src lisp
(defmacro lazy (&body body)
  (let ((forced (gensym))
		(value (gensym)))
	`(let ((,forced nil)
		   (,value nil))
	   (lambda ()
		 (unless ,forced
		   (setf ,value (progn ,@body))
		   (setf ,forced t))
		 ,value))))

(defun force (lazy-value)
  (funcall lazy-value))

(defun lazy-cons (a d)
  `(lazy (cons ,a ,d)))

(defun lazy-car (x)
  (car (force x)))

(defun lazy-cdr (x)
  (cdr (force x)))

(defun lazy-nil ()
  (lazy nil))

(defun lazy-null (x)
  (not (force x)))

(defun make-lazy (lst)
  (lazy (when lst
		  (cons (car lst) (make-lazy (cdr lst))))))

(defun take (n lst)
  (unless (or (zerop n) (lazy-null lst))
	(cons (lazy-car lst) (take (1- n) (lazy-cdr lst)))))

(defun take-all (lst)
  (unless (lazy-null lst)
	(cons (lazy-car lst) (take-all (lazy-cdr lst)))))

(defun lazy-mapcar (fun lst)
  (lazy (unless (lazy-null lst)
		  (cons (funcall fun (lazy-car lst))
				(lazy-mapcar fun (lazy-cdr lst))))))

(defun lazy-mapcan (fun lst)
  (labels ((f (lst-cur)
			 (if (lazy-null lst-cur)
				 (force (lazy-mapcan fun (lazy-cdr lst)))
				 (cons (lazy-car lst-cur) (lazy (f (lazy-cdr lst-cur)))))))
	(lazy (unless (lazy-null lst)
			(f (funcall fun (lazy-car lst)))))))

(defun lazy-find-if (fun lst)
  (unless (lazy-null lst)
	(let ((x (lazy-car lst)))
	  (if (funcall fun x)
		  x
		  (lazy-find-if fun (lazy-cdr lst))))))

(defun lazy-nth (n lst)
  (if (zerop n)
	  (lazy-car lst)
	  (lazy-nth (1- n) (lazy-cdr lst))))
#+end_src
