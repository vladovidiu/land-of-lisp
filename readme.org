#+TITLE: Land of Lisp
#+AUTHOR: Vlad Tutunea

* Introduction
Lisp is a very /expressive/ language.
Once lisp is learned, one will =dream= in lisp :-)

Simple mafs
#+begin_src lisp
(+ 3 (* 2 4))
#+end_src

One of =Lisp='s core characteristics is that writing a Lisp directly in Lisp is, itself, unbelievably simple. Lisp is both *feature-rich* and *tweakable*
- ANSI Common Lisp
- Scheme

Up and coming Lisps
- Arc
- Clojure

Lisp dialects used for scripting
- Emacs Lisp <3
- Guile Scheme
- Script-Fu

* Chapter 2
** Guess my number
#+begin_src lisp
;; Define global variables
(defparameter *small* 1)
(defparameter *big* 100)

;; Define global functions
(defun guess-my-number ()
  (ash (+ *small* *big*) -1))

(defun smaller ()
  (setf *big* (1- (guess-my-number)))
  (guess-my-number))

(defun bigger ()
  (setf *small* (1+ (guess-my-number)))
  (guess-my-number))

(defun start-over ()
  (defparameter *small* 1)
  (defparameter *big* 100)
  (guess-my-number))

;; (start-over) - use the repl to play
#+end_src

Using =*= is a best practice to mark global variables.

** Defining Local Variables
#+begin_src lisp
(let ((a 5)
	  (b 6))
  (+ a b))
#+end_src

** Defining Local Functions
*** flet
#+begin_src lisp
(flet ((f (n)
		 (+ n 10))
	   (g (n)
		 (- n 3)))
  (g (f 5)))
#+end_src

*** labels - have access to previously defined local functions. Also recursion!!
#+begin_src lisp
(labels ((a (n)
		   (+ n 5))
		 (b (n)
		   (+ (a n) 6)))
  (b 10))
#+end_src

#+begin_src lisp
(defun factorial (N)
  (if (= N 1)
	  1
	  (* N (factorial (- N 1)))))

(factorial 5)
#+end_src

* Chapter 3
Having a simple syntax us a defining feature of the =Lisp= language. All basic Lisp code uses list-like syntax.
** Symbols
=Symbols= are a fundamental type of data in Lisp and are used extensively.
eg: =+ - / * = < > ? ! _=. Other eg: =foo, ice9, my-killer-app27, --<<==>>--=
Symbols are /*case-insensitive*/
#+begin_src lisp
(eq 'fooo 'FoOo)
#+end_src

** Numbers
Lisp supports both floating-point numbers and integers. =1= and =1.0= are two different entities in Common Lisp.
#+begin_src lisp
(expt 53 53)
#+end_src
#+begin_src lisp
(/ 4 6)
#+end_src
This returns a =rational number= rather than a fraction. To get a fraction, we can use floating-point numbers.
#+begin_src lisp
(/ 4.0 6)
#+end_src

** Strings
#+begin_src lisp
(princ "Tutti Frutti")
#+end_src
#+begin_src lisp
(princ "He yelled \"Stop that thief!\" from the busy street.")
#+end_src

** Code mode and Data mode
*** Code Mode
Lisp always defaults to =code mode=. Code should be in a speical type of list: a =form=
=(foo bla bla bla bla)=
foo - command
bla bla bla bla - a form
A form is simply a list with special command at the beginning - typically the name of a function.
Two nested forms
#+begin_src lisp
(expt 2 (+ 3 4))
#+end_src

*** Data Mode
Any stuff written in data mode is treated as data. This means the pc will not try to "execute" it.
#+begin_src lisp
'(expt 2 3)
#+end_src
The single quote tells Lisp to treat the subsequent form as a chunk of data - simply a list of items. By using =quoting=, you can tell Lisp to not execute it.

** Lists in Lisp
Lists are a crucial feature in Lisp.
If you were to build a house in Lisp, your walls would be made out of lists. The bricks would be made out of symbols, numbers, and strings. However, a wall needs mortar to hold it together. In Lisp are held together by structures called =cons cells=.

*** Cons Cells
It's made of two little connected boxes, both of which can point at other things. A cons cell can point to another cons cell or another type of Lisp data. It's possible to link cons cells together into lists. In fact, in Lisp, lists are just an abstract illusion - all of them are actually composed of cons cells. They look like Linked Lists.
=(val, pointer)=

*** List Functions
There are 3 basic functions for manipulating cons cells in Lisp: =cons=, =car=, =cdr=.

**** The =cons= Function
If you want to link any two pieces of data in your Lisp program, the usual way to do that is with cons. When =cons= is called, the Lisp compiler typically allocates a small chunk of memory, the cons cell, that can hold two references to the objects being linked.
#+begin_src lisp
(cons 'chicken 'cat)
#+end_src
#+begin_src lisp
(cons 'chicken 'nil)
#+end_src
=nil= is used to terminate a list. Lisp will always go out of its way to "hide" the cons cells from you. It will show you cons cell *only* if there isn't a way to show your results using lists.

#+begin_src lisp
(cons 'chicken ())
#+end_src
#+begin_src lisp
(cons 'pork '(beef chicken))
#+end_src
#+begin_src lisp
(cons 'beef (cons 'chicken ()))
#+end_src
#+begin_src lisp
(cons 'pork (cons 'beef (cons 'chicken ())))
#+end_src

In Lisp, a chain of cons cells and a list are exactly the same thing.

**** The =car= and =cdr= Functions
Lists are just long chains of two-item cells. The =car= function is used for getting the thing out the /first/ slot of a cell (head).
#+begin_src lisp
(car '(pork beef chicken))
#+end_src

The =cdr= function is used to grab the value out of the /second/ slot, or the remainder of the list (tail).
#+begin_src lisp
(cdr '(pork beef chicken))
#+end_src

=cadr=, =cdar= or =cadadr=
#+begin_src lisp
(cadr '(pork beef chicken))
#+end_src

**** The =list= Function
The /list/ function does the dirty work of creating all the cons cells and builds our list all at once:
#+begin_src lisp
(list 'pork 'beef 'chicken)
#+end_src

#+begin_src lisp
(cons 'pork (cons 'beef (cons 'chicken 'nil)))
#+end_src

**** Nested lists
Lists can contain other lists
#+begin_src lisp
'(cat (duck bat) ant)
#+end_src
#+begin_src lisp
(cdar '((peas carrots tomatoes) (pork beef chicken)))
#+end_src
#+begin_src lisp
(cons (cons 'peas (cons 'carrots (cons 'tomatoes ())))
	  (cons (cons 'pork (cons 'beef (cons 'chicken ()))) ()))
#+end_src

cddr - cdr of the cdr of X.
#+begin_src lisp
(cddr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

caddr - car of the cdr of the cdr of X.
#+begin_src lisp
(caddr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

cddar - cdr of the cdr of the car of X.
#+begin_src lisp
(cddar '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

cadadr - car of the cdr of the car of the cdr of X.
#+begin_src lisp
(cadadr '((peas carrots tomatoes) (pork beef chicken) duck))
#+end_src

* Chapter 4
Lisp commands and data structures are imbued with symmetry in every conceivable way.
Note: In Lisp, an empty list evaluates to false.
#+begin_src lisp
(defun my-length (list)
  (if list
	  (1+ (my-length (cdr list)))
	  0))

(my-length '(list with four symbols))
;; This goes like this:
;; 1 + (with four symbols) -> 1 + (four symbols) -> 1 + (symbols) -> 1 + () -> 0
;; 1 + 1 + 1 + 1 + 0 = 4
#+end_src

** The four disguises of /()/
It is the *only* false value in Common Lisp. /Any value not equivalent to an empty list will be considere a true value/
#+begin_src lisp
(eq '() nil)
(eq '() ())
(eq '() 'nil)
;; These evaluate to true
#+end_src
Funny thing -> =nil= is actually a global constant evaluating to /data-mode/ nil.

** The Conditionals: if and beyond
#+begin_src lisp
(if (oddp 5)
	'odd-number
	'even-number)
#+end_src
Usually, when a function is executed in Lisp, all the expressions after the function name are evaluated, before the function itself is evaluated. However, /if/ does not follow these rules.

Since only one expression inside an /if/ is *ever* evaluated, it's impossible to do two or more separate things inside your branch. =progn= to the rescue...
#+begin_src lisp
(defvar *number-was-odd* nil)

(if (oddp 5)
	(progn (setf *number-was-odd* t)
		   'odd-number)
	'even-number)

,*number-was-odd*

#+end_src

** Beyond /if/
Since it's a pain to use =progn= every time, Lisp has several other commands that include an /implicit/ *progn*
=when= and =unless=
#+begin_src lisp
(defvar *number-is-odd* nil)
(when (oddp 5)
  (setf *number-is-odd* t)
  'odd-number)

,*number-is-odd*

(unless (oddp 4)
  (setf *number-is-odd* nil)
  'even-number)

,*number-is-odd*
#+end_src

The problem with =when= and =unless= is that when the conditions evaluate the opposite way, they just return =nil= and do nothing.
=cond= to the rescue...

** The command that does it all: /cond/
#+begin_src lisp
(defvar *arch-enemy* nil)
(defun pudding-eater (person)
  (cond ((eq person 'henry) (setf *arch-enemy* 'stupid-lisp-alien)
		 '(curse you lisp alien - you ate my pudding))
		((eq person 'johnny) (setf *arch-enemy* 'useless-old-johnny)
		 '(i hope you choked on my pudding johnny))
		(t '(why you eat my pudding stranger ?))))

(pudding-eater 'johnny)
,*arch-enemy*
#+end_src
use =case=
#+begin_src lisp
(defun pudding-eater-case (person)
  (case person
	((henry) (setf *arch-enemy* 'henry)
	 '(curse you lisp alien))
	((johnny) (setf *arch-enemy* 'johnny)
	 '(i hope you liked the pudding))
	(otherwise '(who ate my pudding ?))))

(pudding-eater-case 'johnny)
#+end_src

** Cool tricks with conditions
Lisp uses shortcut boolean evaluation (similar to javascript).
Some built-in functions returns more than a boolean; eg: =member= returns true if the list contains the search element, but also returns the tail (=cdr=) past searched element.

** Comparing stuff: /eq/, /equal/, and /more/ 
Lisp has a lot of comparing functions to check if two values are "the same".
=equal, eql, eq, =, string-equal, equalp=

Conrad's Rule of Thumb for Comparing Stuff:
1. use =eq= to compare symbols.
2. use =equal= to compare everything else.

#+begin_src lisp
(defparameter *fruit* 'apple)

(cond ((eq *fruit* 'apple) 'its-an-apple)
	  ((eq *fruit* 'orange) 'its-an-orange))

(eql #\a #\a)

#+end_src

* Chapter 5
** Text Adventure Game
#+begin_src lisp
(defparameter *nodes* '((living-room (you are in the living room.
									  a wizard is snoring loudly on the couch.))
						(garden (you are in a beautiful garden.
								 there is a well in front of you.))
						(attic (you are in the attic.
								there is a giant welding torch in the corner.))))

(defparameter *edges* '((living-room (garden west door)
						 (attic upstairs ladder))
						(garden (living-room east door))
						(attic (living-room downstairs ladder))))

(defparameter *objects* '(whiskey bucket frog chain))

(defparameter *object-location* '((whiskey living-room)
								  (bucket living-room)
								  (chain garden)
								  (frog garden)))

(defparameter *location* 'living-room)

(defun describe-location (location nodes)
  (cadr (assoc location nodes)))

(defun describe-path (edge)
  `(there is a ,(caddr edge) going ,(cadr edge) from here.))

(defun describe-paths (location edges)
  (apply #'append (mapcar #'describe-path (cdr (assoc location edges)))))

(defun object-at (location objects object-location)
  (labels ((at-location-p (object)
			 (eq (cadr (assoc object object-location)) location)))
	(remove-if-not #'at-location-p objects)))

(defun describe-objects (location objects object-location)
  (labels ((describe-object (object)
			 `(you see a ,object on the floor.)))
	(apply #'append (mapcar #'describe-object (object-at location objects object-location)))))

(defun look ()
  (append (describe-location *location* *nodes*)
		  (describe-paths *location* *edges*)
		  (describe-objects *location* *objects* *object-location*)))

(defun walk (direction)
  (let ((next (find direction
					(cdr (assoc *location* *edges*))
					:key #'cadr)))
	(if next
		(progn (setf *location* (car next))
			   (look))
		'(you cannot go that way.))))

(defun pickup (object)
  (cond ((member object
				 (object-at *location* *objects* *object-location*))
		 (push (list object 'body) *object-location*)
		 `(you are now carrying the ,object))
		(t '(you cannot get that.))))

(defun drop (object)
  (cond ((member object
				 (object-at 'body *objects* *object-location*))
		 (push (list object *location*) *object-location*)
		 `(you have dropped the ,object at ,*location*))
		 (t `(you are not carrying ,object))))

(defun inventory ()
  (cons 'items- (object-at 'body *objects* *object-location*)))
#+end_src

=quasiquoting= allows us to create chunks of data that have small pieces of Lisp code embedded in them. Looks similar to javascript's template literal.
='= and =`= /flip/ a piece of code in data mode, but only =`= can also be /unquoted/ using the comma character, to flip back into code mode.

The =push/assoc= idiom is a common technique, because =assoc= returns the first found item, "cheating" having the same item twice; it's like the item is being overwritten.

* Chapter 6
=print/read=

#+begin_src lisp
(defun say-hello ()
  (princ "Please type your name:")
  (let ((name (read-line)))
	(princ "Hello, ")
	(princ name)))
#+end_src
A programming language that uses the same data structures to store and and program code is called =homoiconic=.
Lisp has the infamous =eval= function... Javascript feelings...

#+begin_src lisp
(defparameter *allowed-commands* '(look walk pickup drop inventory))

(defun game-read ()
  (let ((cmd (read-from-string
			  (concatenate 'string "(" (read-line) ")"))))
	(flet ((quote-it (x)
			 (list 'quote x)))
	  (cons (car cmd) (mapcar #'quote-it (cdr cmd))))))

(defun game-eval (sexp)
  (if (member (car sexp) *allowed-commands*)
	  (eval sexp)
	  '(command unknown - try again with "look" "walk" "pickup" "drop" "inventory")))

(defun tweak-text (lst caps lit)
  (when lst
	(let ((item (car lst))
		  (rest (cdr lst)))
	  (cond ((eq item #\space) (cons item (tweak-text rest caps lit)))
			((member item '(#\! #\? #\.)) (cons item (tweak-text rest t lit)))
			((eq item #\") (tweak-text rest caps (not lit)))
			((or caps lit) (cons (char-upcase item) (tweak-text rest nil lit)))
			(t (cons (char-downcase item) (tweak-text rest nil nil)))))))

(defun game-print (lst)
  (princ (coerce (tweak-text (coerce (string-trim "() "
												  (prin1-to-string lst))
									 'list)
							 t
							 nil)
				 'string))
  (fresh-line))

(defun game-repl ()
  (let ((cmd (game-read)))
	(unless (eq (car cmd) 'quit)
	  (game-print (game-eval cmd))
	  (game-repl))))
#+end_src
